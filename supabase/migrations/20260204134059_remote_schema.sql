


SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;


COMMENT ON SCHEMA "public" IS 'standard public schema';



CREATE EXTENSION IF NOT EXISTS "pg_graphql" WITH SCHEMA "graphql";






CREATE EXTENSION IF NOT EXISTS "pg_stat_statements" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "supabase_vault" WITH SCHEMA "vault";






CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA "extensions";






CREATE OR REPLACE FUNCTION "public"."fn_is_photo_owner"("photo_id" "uuid") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  -- 이 쿼리는 RLS를 타지 않고 직접 테이블을 조회합니다.
  RETURN EXISTS (
    SELECT 1 FROM photos 
    WHERE id = photo_id 
    AND user_id = auth.uid()
  );
END;
$$;


ALTER FUNCTION "public"."fn_is_photo_owner"("photo_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_new_user"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
begin
  insert into public.profiles (id, email)
  values (new.id, new.email);
  return new;
end;
$$;


ALTER FUNCTION "public"."handle_new_user"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_album_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_album_updated_at"() OWNER TO "postgres";

SET default_tablespace = '';

SET default_table_access_method = "heap";


CREATE TABLE IF NOT EXISTS "public"."albums" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "title" "text" NOT NULL,
    "description" "text",
    "style_type" "text" NOT NULL,
    "is_public" boolean DEFAULT false,
    "content_data" "jsonb" DEFAULT '{"settings": {}, "photo_ids": []}'::"jsonb" NOT NULL,
    "video_url" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "albums_style_type_check" CHECK (("style_type" = ANY (ARRAY['route_anim'::"text", 'scroll_view'::"text", 'ai_video'::"text"])))
);


ALTER TABLE "public"."albums" OWNER TO "postgres";


COMMENT ON TABLE "public"."albums" IS '무빙 앨범 정보를 저장하는 테이블';



CREATE TABLE IF NOT EXISTS "public"."categories" (
    "id" bigint NOT NULL,
    "user_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "is_favorite" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "color" "text" DEFAULT '#000000'::"text"
);


ALTER TABLE "public"."categories" OWNER TO "postgres";


ALTER TABLE "public"."categories" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."categories_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."friends" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "requester_id" "uuid" NOT NULL,
    "recipient_id" "uuid" NOT NULL,
    "status" character varying(20) DEFAULT 'pending'::character varying,
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    CONSTRAINT "friends_status_check" CHECK ((("status")::"text" = ANY ((ARRAY['pending'::character varying, 'accepted'::character varying, 'blocked'::character varying])::"text"[])))
);


ALTER TABLE "public"."friends" OWNER TO "postgres";


COMMENT ON TABLE "public"."friends" IS '친구 관계 관리 테이블';



CREATE TABLE IF NOT EXISTS "public"."photo_categories" (
    "photo_id" "uuid" NOT NULL,
    "category_id" bigint NOT NULL
);


ALTER TABLE "public"."photo_categories" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."photo_shares" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "photo_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL
);


ALTER TABLE "public"."photo_shares" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."photos" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "storage_path" "text",
    "latitude" double precision NOT NULL,
    "longitude" double precision NOT NULL,
    "taken_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "description" "text",
    "title" "text",
    "visibility" character varying(20) DEFAULT 'private'::character varying,
    "address" "text",
    CONSTRAINT "photos_visibility_check" CHECK ((("visibility")::"text" = ANY ((ARRAY['friends'::character varying, 'specific'::character varying, 'private'::character varying])::"text"[])))
);


ALTER TABLE "public"."photos" OWNER TO "postgres";


COMMENT ON COLUMN "public"."photos"."visibility" IS '사진 공유 범위 (friends: 전체 친구, specific: 특정 친구, private: 나만 보기)';



COMMENT ON COLUMN "public"."photos"."address" IS '사진 촬영 위치 주소 (Kakao Map 기준)';



CREATE TABLE IF NOT EXISTS "public"."profiles" (
    "id" "uuid" NOT NULL,
    "email" "text",
    "address" "text",
    "latitude" double precision,
    "longitude" double precision,
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "nickname" "text",
    "avatar_url" "text",
    "profile_completed" boolean DEFAULT false
);


ALTER TABLE "public"."profiles" OWNER TO "postgres";


COMMENT ON TABLE "public"."profiles" IS '사용자 프로필 (친구 검색 대상)';



ALTER TABLE ONLY "public"."albums"
    ADD CONSTRAINT "albums_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."categories"
    ADD CONSTRAINT "categories_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."categories"
    ADD CONSTRAINT "categories_user_id_name_key" UNIQUE ("user_id", "name");



ALTER TABLE ONLY "public"."friends"
    ADD CONSTRAINT "friends_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."friends"
    ADD CONSTRAINT "friends_requester_id_recipient_id_key" UNIQUE ("requester_id", "recipient_id");



ALTER TABLE ONLY "public"."photo_categories"
    ADD CONSTRAINT "photo_categories_pkey" PRIMARY KEY ("photo_id", "category_id");



ALTER TABLE ONLY "public"."photo_shares"
    ADD CONSTRAINT "photo_shares_photo_id_user_id_key" UNIQUE ("photo_id", "user_id");



ALTER TABLE ONLY "public"."photo_shares"
    ADD CONSTRAINT "photo_shares_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."photos"
    ADD CONSTRAINT "photos_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_pkey" PRIMARY KEY ("id");



CREATE INDEX "idx_albums_created_at" ON "public"."albums" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_albums_is_public" ON "public"."albums" USING "btree" ("is_public") WHERE ("is_public" = true);



CREATE INDEX "idx_albums_user_id" ON "public"."albums" USING "btree" ("user_id");



CREATE INDEX "idx_friends_recipient" ON "public"."friends" USING "btree" ("recipient_id");



CREATE INDEX "idx_friends_requester" ON "public"."friends" USING "btree" ("requester_id");



CREATE INDEX "photo_categories_category_id_idx" ON "public"."photo_categories" USING "btree" ("category_id");



CREATE INDEX "photo_categories_photo_id_idx" ON "public"."photo_categories" USING "btree" ("photo_id");



CREATE UNIQUE INDEX "profiles_nickname_unique" ON "public"."profiles" USING "btree" ("nickname") WHERE ("nickname" IS NOT NULL);



CREATE OR REPLACE TRIGGER "set_album_updated_at" BEFORE UPDATE ON "public"."albums" FOR EACH ROW EXECUTE FUNCTION "public"."update_album_updated_at"();



ALTER TABLE ONLY "public"."albums"
    ADD CONSTRAINT "albums_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."categories"
    ADD CONSTRAINT "categories_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."friends"
    ADD CONSTRAINT "friends_recipient_id_fkey" FOREIGN KEY ("recipient_id") REFERENCES "public"."profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."friends"
    ADD CONSTRAINT "friends_requester_id_fkey" FOREIGN KEY ("requester_id") REFERENCES "public"."profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."photo_categories"
    ADD CONSTRAINT "photo_categories_category_id_fkey" FOREIGN KEY ("category_id") REFERENCES "public"."categories"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."photo_categories"
    ADD CONSTRAINT "photo_categories_photo_id_fkey" FOREIGN KEY ("photo_id") REFERENCES "public"."photos"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."photo_shares"
    ADD CONSTRAINT "photo_shares_photo_id_fkey" FOREIGN KEY ("photo_id") REFERENCES "public"."photos"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."photo_shares"
    ADD CONSTRAINT "photo_shares_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."photos"
    ADD CONSTRAINT "photos_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_id_fkey" FOREIGN KEY ("id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



CREATE POLICY "Anyone can view public albums" ON "public"."albums" FOR SELECT USING (("is_public" = true));



CREATE POLICY "Authenticated users can select all profiles" ON "public"."profiles" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Manage own photos" ON "public"."photos" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Photo owners can manage shares" ON "public"."photo_shares" USING ("public"."fn_is_photo_owner"("photo_id")) WITH CHECK ("public"."fn_is_photo_owner"("photo_id"));



CREATE POLICY "Public albums are viewable by everyone" ON "public"."albums" FOR SELECT USING (("is_public" = true));



CREATE POLICY "Public profiles are viewable by everyone." ON "public"."profiles" FOR SELECT USING (true);



CREATE POLICY "Shared users can see share record" ON "public"."photo_shares" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can create own albums" ON "public"."albums" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can delete own albums" ON "public"."albums" FOR DELETE USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can delete their own friend records" ON "public"."friends" FOR DELETE TO "authenticated" USING ((("auth"."uid"() = "requester_id") OR ("auth"."uid"() = "recipient_id")));



CREATE POLICY "Users can insert friend requests" ON "public"."friends" FOR INSERT TO "authenticated" WITH CHECK (("auth"."uid"() = "requester_id"));



CREATE POLICY "Users can insert own profile" ON "public"."profiles" FOR INSERT WITH CHECK (("auth"."uid"() = "id"));



CREATE POLICY "Users can insert their own profile." ON "public"."profiles" FOR INSERT WITH CHECK (("auth"."uid"() = "id"));



CREATE POLICY "Users can manage their own categories" ON "public"."categories" USING (("auth"."uid"() = "user_id")) WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can manage their own photo categories" ON "public"."photo_categories" USING ((EXISTS ( SELECT 1
   FROM "public"."categories"
  WHERE (("categories"."id" = "photo_categories"."category_id") AND ("categories"."user_id" = "auth"."uid"()))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."categories"
  WHERE (("categories"."id" = "photo_categories"."category_id") AND ("categories"."user_id" = "auth"."uid"())))));



CREATE POLICY "Users can see their own friend requests" ON "public"."friends" FOR SELECT USING ((("auth"."uid"() = "requester_id") OR ("auth"."uid"() = "recipient_id")));



CREATE POLICY "Users can update own albums" ON "public"."albums" FOR UPDATE USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can update own profile" ON "public"."profiles" FOR UPDATE USING (("auth"."uid"() = "id"));



CREATE POLICY "Users can update own profile." ON "public"."profiles" FOR UPDATE USING (("auth"."uid"() = "id"));



CREATE POLICY "Users can update their own friend records" ON "public"."friends" FOR UPDATE TO "authenticated" USING ((("auth"."uid"() = "requester_id") OR ("auth"."uid"() = "recipient_id")));



CREATE POLICY "Users can update their own friend requests" ON "public"."friends" FOR UPDATE USING ((("auth"."uid"() = "requester_id") OR ("auth"."uid"() = "recipient_id")));



CREATE POLICY "Users can view own albums" ON "public"."albums" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can view their own friend records" ON "public"."friends" FOR SELECT TO "authenticated" USING ((("auth"."uid"() = "requester_id") OR ("auth"."uid"() = "recipient_id")));



CREATE POLICY "View friends photos" ON "public"."photos" FOR SELECT USING (((("visibility")::"text" = 'friends'::"text") AND (EXISTS ( SELECT 1
   FROM "public"."friends"
  WHERE ((("friends"."requester_id" = "auth"."uid"()) AND ("friends"."recipient_id" = "photos"."user_id") AND (("friends"."status")::"text" = 'accepted'::"text")) OR (("friends"."recipient_id" = "auth"."uid"()) AND ("friends"."requester_id" = "photos"."user_id") AND (("friends"."status")::"text" = 'accepted'::"text")))))));



CREATE POLICY "View own photos" ON "public"."photos" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "View specific shared photos" ON "public"."photos" FOR SELECT USING (((("visibility")::"text" = 'specific'::"text") AND (EXISTS ( SELECT 1
   FROM "public"."photo_shares"
  WHERE (("photo_shares"."photo_id" = "photos"."id") AND ("photo_shares"."user_id" = "auth"."uid"()))))));



ALTER TABLE "public"."albums" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."categories" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."friends" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."photo_categories" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."photo_shares" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."photos" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."profiles" ENABLE ROW LEVEL SECURITY;




ALTER PUBLICATION "supabase_realtime" OWNER TO "postgres";


GRANT USAGE ON SCHEMA "public" TO "postgres";
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";

























































































































































GRANT ALL ON FUNCTION "public"."fn_is_photo_owner"("photo_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."fn_is_photo_owner"("photo_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."fn_is_photo_owner"("photo_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_album_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_album_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_album_updated_at"() TO "service_role";


















GRANT ALL ON TABLE "public"."albums" TO "anon";
GRANT ALL ON TABLE "public"."albums" TO "authenticated";
GRANT ALL ON TABLE "public"."albums" TO "service_role";



GRANT ALL ON TABLE "public"."categories" TO "anon";
GRANT ALL ON TABLE "public"."categories" TO "authenticated";
GRANT ALL ON TABLE "public"."categories" TO "service_role";



GRANT ALL ON SEQUENCE "public"."categories_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."categories_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."categories_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."friends" TO "anon";
GRANT ALL ON TABLE "public"."friends" TO "authenticated";
GRANT ALL ON TABLE "public"."friends" TO "service_role";



GRANT ALL ON TABLE "public"."photo_categories" TO "anon";
GRANT ALL ON TABLE "public"."photo_categories" TO "authenticated";
GRANT ALL ON TABLE "public"."photo_categories" TO "service_role";



GRANT ALL ON TABLE "public"."photo_shares" TO "anon";
GRANT ALL ON TABLE "public"."photo_shares" TO "authenticated";
GRANT ALL ON TABLE "public"."photo_shares" TO "service_role";



GRANT ALL ON TABLE "public"."photos" TO "anon";
GRANT ALL ON TABLE "public"."photos" TO "authenticated";
GRANT ALL ON TABLE "public"."photos" TO "service_role";



GRANT ALL ON TABLE "public"."profiles" TO "anon";
GRANT ALL ON TABLE "public"."profiles" TO "authenticated";
GRANT ALL ON TABLE "public"."profiles" TO "service_role";









ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "service_role";































drop extension if exists "pg_net";

alter table "public"."friends" drop constraint "friends_status_check";

alter table "public"."photos" drop constraint "photos_visibility_check";

alter table "public"."friends" add constraint "friends_status_check" CHECK (((status)::text = ANY ((ARRAY['pending'::character varying, 'accepted'::character varying, 'blocked'::character varying])::text[]))) not valid;

alter table "public"."friends" validate constraint "friends_status_check";

alter table "public"."photos" add constraint "photos_visibility_check" CHECK (((visibility)::text = ANY ((ARRAY['friends'::character varying, 'specific'::character varying, 'private'::character varying])::text[]))) not valid;

alter table "public"."photos" validate constraint "photos_visibility_check";

CREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();


  create policy "Give users access to own folder 1okq_0"
  on "storage"."objects"
  as permissive
  for insert
  to public
with check (((bucket_id = 'photos'::text) AND (auth.uid() = owner)));



  create policy "Public Access 1okq_1"
  on "storage"."objects"
  as permissive
  for select
  to public
using ((bucket_id = 'photos'::text));



